<!DOCTYPE html>
<html>
<head>
  <title>3D Globe with Google Sheet Data</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans&display=swap" rel="stylesheet">
  <style>
    body { margin: 0; }
    canvas { display: block; }
    #popup {
      position: absolute;
      background-color: white;
      padding: 10px;
      border: 1px solid black;
      display: none;
      font-family: 'Open Sans', serif;
      color: #0e416c;
      max-width: 300px;
      overflow-y: auto;
      word-wrap: break-word;
      border-radius: 10px;
    }
    #popup img {
      max-width: 100%;
      height: auto;
    }
  </style>
</head>
<body>
  <div id="popup">
    <div class="popup-content">
      <h1 id="location-title"></h1>
      <div id="location-description"></div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@latest/build/three.min.js"></script>
  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    const geometry = new THREE.SphereGeometry(1, 32, 32);
    const texture = new THREE.TextureLoader().load('8081_earthmap10k.jpg');
    const material = new THREE.MeshBasicMaterial({ map: texture });
    const globe = new THREE.Mesh(geometry, material);
    scene.add(globe);
    camera.position.z = 2;

    // Fetch data from Google Sheet (replace with your actual Google Sheet link)
    fetch('https://docs.google.com/spreadsheets/d/e/2PACX-1vSs2rlk41tTDPVINsSDUBax78CqTqMxmJ16_LHeHFw-hcqFwtWKN0EeRFf-8mnAsY0e-4d1wWdyRfSO/pub?gid=0&single=true&output=csv')
      .then(response => response.text())
      .then(data => {
        const locations = parseCSV(data);
        addPinsToGlobe(locations);
      });

    function parseCSV(csvData) {
      const rows = csvData.split('\n');
      const headers = rows[0].split(',');
      const locations =[];

      for (let i = 1; i < rows.length; i++) {
        const row = rows[i].split(',');
        const location = {};

        for (let j = 0; j < headers.length; j++) {
          const header = headers[j].trim();
          location[header] = row[j];
        }

        locations.push(location);
      }

      return locations;
    }

    function latLongToVector3(lat, lng) {
      const phi = (90 - lat) * Math.PI / 180;
      const theta = (lng + 180) * Math.PI / 180;
      const x = -Math.sin(phi) * Math.cos(theta);
      const y = Math.cos(phi);
      const z = Math.sin(phi) * Math.sin(theta);
      return new THREE.Vector3(x, y, z);
    }

    function addPinsToGlobe(locations) {
      // Create materials for each machine type (replace with your actual image URLs)
      const excavatorMaterial = new THREE.SpriteMaterial({
        map: new THREE.TextureLoader().load('Icons/Screenshot_2025-03-06_145913-removebg-preview.png', undefined, undefined, (err) => {
            console.error('Error loading excavator image:', err);
        })
      });
      const dozerMaterial = new THREE.SpriteMaterial({
        map: new THREE.TextureLoader().load('Icons/Dozer-removebg-preview.png', undefined, undefined, (err) => {
            console.error('Error loading dozer image:', err);
        })
      });
      const compactorMaterial = new THREE.SpriteMaterial({
        map: new THREE.TextureLoader().load('Icons/Compactor-removebg-preview.png', undefined, undefined, (err) => {
            console.error('Error loading compactor image:', err);
        })
      });
      const ctlMaterial = new THREE.SpriteMaterial({
        map: new THREE.TextureLoader().load('Icons/Dozer-removebg-preview.png', undefined, undefined, (err) => {
            console.error('Error loading ctl image:', err);
        })
      });
      const graderMaterial = new THREE.SpriteMaterial({
        map: new THREE.TextureLoader().load('Icons/Grader-removebg-preview.png', undefined, undefined, (err) => {
            console.error('Error loading ts image:', err);
        })
      });
      const tsMaterial = new THREE.SpriteMaterial({
        map: new THREE.TextureLoader().load('Icons/Total_Station-removebg-preview.png', undefined, undefined, (err) => {
            console.error('Error loading ts image:', err);
        })
      });

      locations.forEach(location => {
        let pinMaterial;

        const machineType = location.MachineType ? location.MachineType.toLowerCase().trim() : '';

        // Assign pinMaterial based on location.MachineType
        switch (machineType) {
            case 'excavator': pinMaterial = excavatorMaterial; break;
            case 'dozer': pinMaterial = dozerMaterial; break;
            case 'compactor': pinMaterial = compactorMaterial; break;
            case 'ctl': pinMaterial = ctlMaterial; break;
            case 'ts': pinMaterial = tsMaterial; break;
            case 'grader': pinMaterial = graderMaterial; break;
            default: 
                console.warn(`Unknown machine type: ${location.MachineType}. Using default.`);
                pinMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Default material
        }

        // Create a sprite for the image
        const pin = new THREE.Sprite(pinMaterial);

        const locationVector = latLongToVector3(parseFloat(location.Latitude), parseFloat(location.Longitude));
        pin.position.copy(locationVector);
        pin.position.setLength(1.045); // Adjust distance from globe surface
        pin.scale.set(0.075, 0.075, 0.075); // Adjust pin size

        pin.userData = {
            title: location.Location,
            description: location.Description
        };

        globe.add(pin);
      });
    }

    // Add event listeners for mouse interaction
    renderer.domElement.addEventListener('mousedown', onMouseDown, false);
    renderer.domElement.addEventListener('mousemove', onMouseMove, false);
    renderer.domElement.addEventListener('mouseup', onMouseUp, false);
    renderer.domElement.addEventListener('click', onClick, false);

    // Add zoom functionality
    renderer.domElement.addEventListener('wheel', onMouseWheel, false);

    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let isRotating = true; // Flag to control rotation

    function onMouseDown(event) {
      isDragging = true;
      previousMousePosition = { x: event.clientX, y: event.clientY };
      isRotating = false; // Stop rotation when mouse is down
    }

    function onMouseMove(event) {
      if (!isDragging) return;
      const deltaX = event.clientX - previousMousePosition.x;
      const deltaY = event.clientY - previousMousePosition.y;
      globe.rotation.y += deltaX * 0.005;
      globe.rotation.x += deltaY * 0.005;
      previousMousePosition = { x: event.clientX, y: event.clientY };
    }

    function onMouseUp() {
      isDragging = false;
      // Resume rotation after 5 seconds
      setTimeout(() => {
        isRotating = true;
      }, 6000);
    }

    function onClick(event) {
      const mouse = new THREE.Vector2();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(globe.children);
      if (intersects.length > 0) {
        const intersect = intersects[0];
        if (intersect.object instanceof THREE.Sprite) { // Check if it's a sprite
          const popup = document.getElementById('popup');
          const titleElement = document.getElementById('location-title');
          const descriptionElement = document.getElementById('location-description');
          const locationData = intersect.object.userData;

          titleElement.textContent = locationData.title;
          descriptionElement.textContent = locationData.description;

          const screenPosition = intersect.object.position.clone().project(camera);
          const x = (screenPosition.x + 1) * window.innerWidth / 2;
          const y = -(screenPosition.y - 1) * window.innerHeight / 2;
          const popupWidth = popup.offsetWidth;
          popup.style.left = (x - popupWidth / 2) + 'px';
          popup.style.top = y + 'px';
          popup.style.display = 'block';
        }
      } else {
        const popup = document.getElementById('popup');
        popup.style.display = 'none';
      }
    }

    function onMouseWheel(event) {
      event.preventDefault();
      const delta = Math.sign(event.deltaY);
      camera.position.z += delta * 0.2;
      camera.position.z = Math.max(1.5, Math.min(10, camera.position.z));
    }

    // Create a particle system for the stars
    const starGeometry = new THREE.BufferGeometry();
    const starMaterial = new THREE.PointsMaterial({ color: 0xffffff });
    const starVertices =[];
    for (let i = 0; i < 10000; i++) {
      const x = (Math.random() - 0.5) * 2000;
      const y = (Math.random() - 0.5) * 2000;
      const z = (Math.random() - 0.5) * 2000;
      starVertices.push(x, y, z);
    }
    starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
    const stars = new THREE.Points(starGeometry, starMaterial);
    scene.add(stars);

    function animate() {
      requestAnimationFrame(animate);

      // Make pins face the camera
      globe.children.forEach(pin => {
        if (pin instanceof THREE.Sprite) { // Check if it's a sprite
          pin.lookAt(camera.position);
        }
      });

      if (isRotating) {
        globe.rotation.y += 0.003;
      }
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
